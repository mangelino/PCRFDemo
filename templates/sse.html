<!DOCTYPE html>




<html lang="en" dir="ltr" itemscope itemtype="http://schema.org/Article">
<head>
  <meta charset="utf-8">
  <meta property="twitter:account_id" content="1593210261" />
  <!-- Copyright (c) 2012 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * Author: Eric Bidelman <e.bidelman@chromium.org>
   *
   * 
   *
  -->
  <title>Stream Updates with Server-Sent Events - HTML5 Rocks</title>
  <meta name="description" content="The EventSource API is designed for receiving push notifications from a server, removing the need for client-size XHR polling.">
  <meta name="keywords" content="html5,html 5,html5 demos,html5 examples,javascript,css3,notifications,geolocation,web workers,apppcache,file api,filereader,indexeddb,offline,audio,video,drag and drop,chrome,sse,mobile">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
  <meta name="theme-color" content="#f04530">
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="alternate" type="application/rss+xml" title="HTML5 Rocks RSS" href="http://feeds.feedburner.com/html5rocks">
  <meta name="google-site-verification" content="E1HOIDkksrWY5npenL8FeQhKn4Ujctd75iO2lfufSyA" />
  <meta itemprop="name" content="Stream Updates with Server-Sent Events - HTML5 Rocks">
  <meta itemprop="description" content="The EventSource API is designed for receiving push notifications from a server, removing the need for client-size XHR polling.">
  
  <meta itemprop="image" content="http://www.html5rocks.com/static/images/html5rocks-logo-wings.png">
  

  
  <meta name="twitter:card" content="summary">
  <meta name="twitter:site" content="@ChromiumDev">
  <meta name="twitter:creator" content="@ebidel">

  <meta property="og:type" content="article">
  <meta property="og:title" content="Stream Updates with Server-Sent Events - HTML5 Rocks">
  <meta property="og:url" content="http://www.html5rocks.com/en/tutorials/eventsource/basics/">
  <meta property="og:description" content="The EventSource API is designed for receiving push notifications from a server, removing the need for client-size XHR polling.">
  <meta property="og:image" content="http://www.html5rocks.com/static/images/profiles/ericbidelman.png">
  <meta property="og:site_name" content="HTML5 Rocks - A resource for open web HTML5 developers">
  

  
  <link rel="author" href="https://www.google.com/profiles/118075919496626375791">
  
  
  <link rel="publisher" href="https://plus.google.com/+GoogleChromeDevelopers">

  

  
    
    <link rel="stylesheet" media="all" href="/static/css/v2-combined.min.css?20131111">
    

    
  

  <link href="//fonts.googleapis.com/css?family=Open+Sans:300,400,400italic,600,800|Source+Code+Pro" rel="stylesheet">

  <link rel="apple-touch-icon" href="/static/images/identity/HTML5_Badge_64.png">
  <link rel="apple-touch-icon-precomposed" href="/static/images/identity/HTML5_Badge_64.png">

  <script src="/static/js/modernizr.custom.82437.js"></script>

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5-els.js"></script>
  <![endif]-->

  
<style>
</style>

</head>
<body data-href="tutorials-eventsource-basics" onload="" class="article tutorial">

  <header class="main" id="siteheader">
    <h1 id="title">
      <a href="/en/" title="HTML5 Rocks">HTML5 Rocks</a>
    </h1>
    <a href="#sitenav" id="navtoggle">Show navigation</a>

    
    <a id="toctoggle" href="#toc">Table of Contents</a>
    

    <nav id="sitenav">
      <ul>
        
        <li id="home_menu"><a href="/en/" class="home">Home</a></li>
        
        <li id="tutorials_menu"><a href="/en/tutorials/?page=1" class="tutorials">Tutorials</a></li>
        <li id="updates_menu"><a href="http://updates.html5rocks.com/" class="updates">Updates</a></li>
      </ul>
    </nav>

    
    <nav class="toc" id="toc">
      <h1>Table of Contents</h1>

      <ul><li><a href='#toc-introduction'>Introduction</a></li><li><a href='#toc-introduction-differences'>Server-Sent Events vs. WebSockets</a></li><li><a href='#toc-js-api'>JavaScript API</a></li><li><a href='#toc-event-stream-format'>Event Stream Format</a></li><li><a href='#toc-server-code'>Server Examples</a></li><li><a href='#toc-canceling'>Cancel an Event Stream</a></li><li><a href='#toc-security'>A Word on Security</a></li><li><a href='#toc-demo'>Demo</a></li><li><a href='#toc-references'>References</a></li></ul>

      <h1 class="visible-title">Localizations:</h1>
      <ul>
        
          <li><a href="https://github.com/html5rocks/www.html5rocks.com/blob/master/CONTRIBUTING.md">Contribute one</a></li>
        
      </ul>
    </nav>
    
  </header>

  <div class="body-content">
    

  <section class="title">

    

    <section class="title-text container">
      
      <h1>Stream Updates with Server-Sent Events</h1>
      
      

      <a href="/en/" class="watermark">HTML5 Rocks</a>
    </section>
  </section>

  <article class="content-wrapper">

    <section class="container">

      

      <div class="article-meta" id="article-meta">
        <nav class="toc">
          <h1>Table of Contents</h1>

          <ul><li><a href='#toc-introduction'>Introduction</a></li><li><a href='#toc-introduction-differences'>Server-Sent Events vs. WebSockets</a></li><li><a href='#toc-js-api'>JavaScript API</a></li><li><a href='#toc-event-stream-format'>Event Stream Format</a></li><li><a href='#toc-server-code'>Server Examples</a></li><li><a href='#toc-canceling'>Cancel an Event Stream</a></li><li><a href='#toc-security'>A Word on Security</a></li><li><a href='#toc-demo'>Demo</a></li><li><a href='#toc-references'>References</a></li></ul>
        </nav>

        <aside class="localizations">
          <h1>Localizations</h1>
          <ul>
            
              <li><a href="https://github.com/html5rocks/www.html5rocks.com/blob/master/CONTRIBUTING.md">Contribute one</a></li>
            
          </ul>
        </aside>
      </div>
      

      <div class="content" id="article-content">

        <section class="byline">

          <div class="byline-content">
            
            <section class="author-images">
              <a href="/profiles/#ericbidelman">
                <img src="/static/images/profiles/ericbidelman.png" itemprop="photo" alt="Eric Bidelman" title="Eric Bidelman">
              </a>

              
            </section>

            <section class="meta">
              <div class="authors">
                <strong>By</strong> <a href="/profiles/#ericbidelman">Eric Bidelman</a>
                
              </div>

              

              <div class="date">
                <time pubdate><strong>Published:</strong> November 30th, 2010</time>
                
                <span><strong>Comments:</strong> <a href="#disqus_thread" class="load-comments" data-disqus-identifier="http://www.html5rocks.com/tutorials/eventsource/basics/">0</a></span>
              </div>

              <div id="notcompatible" class="hidden">
                Your browser may not support the functionality in this article.
              </div>
            </section>
            <div class="clear"></div>

            
          </div>
        </section>

        
  <h2 id="toc-introduction">Introduction</h2>
  <p>I wouldn't be surprised if you've stumbled on this article wondering, "What the heck are
  <a href="http://dev.w3.org/html5/eventsource/">Server-Sent Events</a> (<abbr title="Server-Sent Events">SSE</abbr>s)?" Many people
  have never heard of them, and rightfully so. Over the years, the specification has seen significant
  changes, and the API has taken somewhat of a backseat to newer, sexier communication
  protocols such as the <a href="/tutorials/#websockets">WebSocket API</a>. The idea behind
  <abbr title="Server-Sent Events">SSE</abbr>s may be familiar: a web app "subscribes" to a
  stream of updates generated by a server and, whenever a new event occurs, a notification is sent to
  the client. But to really understand Server-Sent Events, we need to understand the limitations
  of its AJAX predecessors, which includes:</p>

  <p><strong>Polling</strong> is a traditional technique used by the vast majority of AJAX applications.
  The basic idea is that the application repeatedly polls a server for data.
  If you're familiar with the HTTP protocol, you know that fetching data revolves around a request/response format.
  The client makes a request and waits for the server to respond with data. If none is available, an empty response
  is returned. So what's the big deal with polling? Extra polling creates greater HTTP overhead.</p>

  <p><strong>Long polling (Hanging GET / COMET)</strong> is a slight variation on polling.
  In long polling, if the server does not have data available, the server holds the request
  open until new data is made available. Hence, this technique is often referred to as a "Hanging GET".
  When information becomes available, the server responds, closes the connection, and the process is repeated.
  The effect is that the server is constantly responding with new data as it becomes available.
  The shortcoming is that the implementation of such a procedure typically involves hacks such
  as appending script tags to an 'infinite' iframe. We can do better than hacks!</p>

  <p>Server-Sent Events on the other hand, have been designed from the ground up to be efficient.
  When communicating using <abbr title="Server-Sent Events">SSE</abbr>s, a server can push data to your
  app whenever it wants, without the need to make an initial request. In other words,
  updates can be streamed from server to client as they happen. <abbr title="Server-Sent Events">SSE</abbr>s
  open a single unidirectional channel between server and client.</p>

  <p>The main difference between Server-Sent Events and long-polling is that <abbr title="Server-Sent Events">SSE</abbr>s
  are handled directly by the browser and the user simply has to listen for messages.</p>

  <h2 id="toc-introduction-differences">Server-Sent Events vs. WebSockets</h2>

  <p>Why would you choose Server-Sent Events over WebSockets? Good question.</p>

  <p>One reason <abbr title="Server-Sent Events">SSE</abbr>s have been kept in the shadow is because
  later APIs like <a href="/tutorials/#websockets">WebSockets</a> provide a richer protocol to perform bi-directional,
  full-duplex communication. Having a two-way channel is more attractive for things like games, messaging apps, and for
  cases where you need near real-time updates in both
  directions. However, in some scenarios <i>data doesn't need to be sent from the client</i>. You simply
  need updates from some server action. A few examples would be friends' status updates, stock tickers,
  news feeds, or other automated data push mechanisms (e.g. updating a client-side
  Web SQL Database or IndexedDB object store). If you'll need to send data to a server,
  <code>XMLHttpRequest</code> is always a friend.</p>

  <p><abbr title="Server-Sent Events">SSE</abbr>s are sent over traditional HTTP. That means they <i>do not require a special protocol or server
  implementation</i> to get working. WebSockets on the other hand, require full-duplex connections
  and new Web Socket servers to handle the protocol. In addition, Server-Sent Events  have a variety
  of features that WebSockets lack by design such as <i>automatic reconnection</i>, <i>event IDs</i>,
  and the ability to <i>send arbitrary events</i>.</p>

  <h2 id="toc-js-api">JavaScript API</h2>

  <p>To subscribe to an event stream, create an <code>EventSource</code> object and pass it the
  URL of your stream:</p>

  <pre class="prettyprint">
if (!!window.EventSource) {
  var source = new EventSource('stream.php');
} else {
  // Result to xhr polling :(
}
</pre>

  <p><strong>Note:</strong> If the URL passed to the <code>EventSource</code> constructor
  is an absolute URL, its origin (scheme, domain, port) must match that of the calling page.</p>

  <p>Next, set up a handler for the <code>message</code> event. You can optionally
  listen for <code>open</code> and <code>error</code>:</p>

  <pre class="prettyprint">
source.addEventListener('message', function(e) {
  console.log(e.data);
}, false);

source.addEventListener('open', function(e) {
  // Connection was opened.
}, false);

source.addEventListener('error', function(e) {
  if (e.readyState == EventSource.CLOSED) {
    // Connection was closed.
  }
}, false);
</pre>

  <p>When updates are pushed from the server, the <code>onmessage</code> handler fires
  and new data is be available in its <code>e.data</code> property. The magical part is
  that whenever the connection is closed, the browser will automatically reconnect to the
  source after ~3 seconds. Your server implementation can even have control over
  this reconnection timeout. See <a href="#toc-reconnection-timeout">Controlling the reconnection-timeout</a>
  in the next section.</p>

  <p>That's it. Your client is now ready to process events from <code>stream.php</code>.</p>

  <h2 id="toc-event-stream-format">Event Stream Format</h2>

  <p>Sending an event stream from the source is a matter of constructing a
  plaintext response, served with a <code>text/event-stream</code> Content-Type,
  that follows the <abbr title="Server-Sent Events">SSE</abbr> format.
  In its basic form, the response should contain a "<code>data:</code>" line, followed by your message, followed by
  two "\n" characters to end the stream:</p>

  <pre class="prettyprint">data: My message\n\n</pre>

  <h3 id="toc-multiline-data">Multiline Data</h3>

  <p>If your message is longer, you can break it up by using multiple "<code>data:</code>" lines. Two
  or more consecutive lines beginning with "<code>data:</code>" will be treated as a
  single piece of data, meaning only one <code>message</code> event will be fired.
  Each line should end in a single "\n" (except for the last, which should end with two).
  The result passed to your <code>message</code> handler is a single string concatenated by newline characters. For example:</p>

  <pre class="prettyprint">
data: first line\n
data: second line\n\n</pre>

  <p>will produce "first line\nsecond line" in <code>e.data</code>. One could then use <code>e.data.split('\n').join('')</code>
  to reconstruct the message sans "\n" characters.</p>

  <h3 id="toc-json-data">Send JSON Data</h3>

  <p>Using multiple lines makes it easy to send JSON without breaking syntax:</p>

    <pre class="prettyprint">
data: {\n
data: "msg": "hello world",\n
data: "id": 12345\n
data: }\n\n</pre>

    <p>and possible client-side code to handle that stream:</p>

    <pre class="prettyprint">
source.addEventListener('message', function(e) {
  var data = JSON.parse(e.data);
  console.log(data.id, data.msg);
}, false);
</pre>

    <h3 id="toc-lastevent-id">Associating an ID with an Event</h3>

    <p>You can send a unique id with an stream event by including a line starting with "<code>id:</code>":</p>

    <pre class="prettyprint">
id: 12345\n
data: GOOG\n
data: 556\n\n</pre>

    <p>Setting an ID lets the browser keep track of the last event fired so that if, the
    connection to the server is dropped, a special HTTP header (<code>Last-Event-ID</code>) is
    set with the new request. This lets the browser determine which event is appropriate to fire.
    The <code>message</code> event contains a <code>e.lastEventId</code> property.</p>

    <h3 id="toc-reconnection-timeout">Controlling the Reconnection-timeout</h3>

    <p>The browser attempts to reconnect to the source roughly 3 seconds
    after each connection is closed. You can change that timeout by including a
    line beginning with "<code>retry:</code>", followed by the number of milliseconds
    to wait before trying to reconnect.</p>

    <p>The following example attempts a reconnect after 10 seconds:</p>

    <pre class="prettyprint">
retry: 10000\n
data: hello world\n\n</pre>

   <h3 id="toc-eventname">Specifying an event name</h3>

   <p>A single event source can generate different types events by including an
   event name. If a line beginning with "<code>event:</code>" is present,
   followed by a unique name for the event, the event is associated with that name.
   On the client, an event listener can be setup to listen to that particular event. </p>

   <p>For example, the following server output sends three types of events,
    a generic 'message' event, 'userlogon', and 'update' event:</p>

   <pre class="prettyprint">
data: {"msg": "First message"}\n\n
event: userlogon\n
data: {"username": "John123"}\n\n
event: update\n
data: {"username": "John123", "emotion": "happy"}\n\n
</pre>

    <p>With event listeners setup on the client:</p>

    <pre class="prettyprint">
source.addEventListener('message', function(e) {
  var data = JSON.parse(e.data);
  console.log(data.msg);
}, false);

source.addEventListener('userlogon', function(e) {
  var data = JSON.parse(e.data);
  console.log('User login:' + data.username);
}, false);

source.addEventListener('update', function(e) {
  var data = JSON.parse(e.data);
  console.log(data.username + ' is now ' + data.emotion);
}, false);
</pre>

  <h2 id="toc-server-code">Server Examples</h2>

  <p>A simple server implementation in PHP:</p>

<pre class="prettyprint">
&lt;?php
header('Content-Type: text/event-stream');
header('Cache-Control: no-cache'); // recommended to prevent caching of event data.

/**
 * Constructs the SSE data format and flushes that data to the client.
 *
 * @param string $id Timestamp/id of this connection.
 * @param string $msg Line of text that should be transmitted.
 */
function sendMsg($id, $msg) {
  echo "id: $id" . PHP_EOL;
  echo "data: $msg" . PHP_EOL;
  echo PHP_EOL;
  ob_flush();
  flush();
}

$serverTime = time();

sendMsg($serverTime, 'server time: ' . date("h:i:s", time()));
</pre>

  <p><a href="demo/sse.php">Download the code</a></p>

  <p>Here's a similiar implementation using <a href="http://nodejs.org">Node JS</a>:</p>

  <pre class="prettyprint">
var http = require('http');
var sys = require('sys');
var fs = require('fs');

http.createServer(function(req, res) {
  //debugHeaders(req);

  if (req.headers.accept && req.headers.accept == 'text/event-stream') {
    if (req.url == '/events') {
      sendSSE(req, res);
    } else {
      res.writeHead(404);
      res.end();
    }
  } else {
    res.writeHead(200, {'Content-Type': 'text/html'});
    res.write(fs.readFileSync(__dirname + '/sse-node.html'));
    res.end();
  }
}).listen(8000);

function sendSSE(req, res) {
  res.writeHead(200, {
    'Content-Type': 'text/event-stream',
    'Cache-Control': 'no-cache',
    'Connection': 'keep-alive'
  });

  var id = (new Date()).toLocaleTimeString();

  // Sends a SSE every 5 seconds on a single connection.
  setInterval(function() {
    constructSSE(res, id, (new Date()).toLocaleTimeString());
  }, 5000);

  constructSSE(res, id, (new Date()).toLocaleTimeString());
}

function constructSSE(res, id, data) {
  res.write('id: ' + id + '\n');
  res.write("data: " + data + '\n\n');
}

function debugHeaders(req) {
  sys.puts('URL: ' + req.url);
  for (var key in req.headers) {
    sys.puts(key + ': ' + req.headers[key]);
  }
  sys.puts('\n\n');
}
</pre>

  <p><a href="demo/node-sse.js">Download the code</a></p>

  <h4>sse-node.html:</h4>
  <pre class="prettyprint">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot; /&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;script&gt;
    var source = new EventSource('/events');
    source.onmessage = function(e) {
      document.body.innerHTML += e.data + '&lt;br&gt;';
    };
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>

  <h2 id="toc-canceling">Cancel an Event Stream</h2>

  <p>Normally, the browser auto-reconnects to the event source when the connection
  is closed, but that behavior can be canceled from either the client or server.</p>

  <p>To cancel a stream from the client, simply call:</p>

  <pre class="prettyprint">source.close();</pre>

  <p>To cancel a stream from the server, respond with a non "<code>text/event-stream</code>"
  <code>Content-Type</code> or return an HTTP status other than <code>200 OK</code>
  (e.g. <code>404 Not Found</code>).</p>

  <p>Both methods will prevent the browser from re-establishing the connection.</p>

  <h2 id="toc-security">A Word on Security</h2>

  <p>From the WHATWG's section on <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#authors">Cross-document messaging security</a>:</p>

  <blockquote><q><i>Authors should check the origin attribute to ensure that messages are only accepted from domains that
  they expect to receive messages from. Otherwise, bugs in the author's message handling code could
  be exploited by hostile sites.</i></q></blockquote>

  <p>So, as an extra level of precaution, be sure to verify <code>e.origin</code> in
  your <code>message</code> handler matches your app's origin:</p>

  <pre class="prettyprint">
source.addEventListener('message', function(e) {
  if (e.origin != 'http://example.com') {
    alert('Origin was not http://example.com');
    return;
  }
  ...
}, false);
</pre>

  <p>Another good idea is to check the integrity of the data you receive:</p>

  <blockquote><q><i>Furthermore, even after checking the origin attribute, authors should also check that the data in
  question is of the expected format....
  </i></q></blockquote>

  <h2 id="toc-demo">Demo</h2>
  
  <p>I've written a <a href="https://github.com/html5rocks/www.html5rocks.com/tree/master/content/tutorials/eventsource/basics/static/demo">demo app</a> in PHP that keeps a clock up to date form the server.</p>

  <h2 id="toc-references">References</h2>
  <ul>
    <li><a href="http://dev.w3.org/html5/eventsource/">Server-Sent Events specification</a></li>
    <li><a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#authors">Cross-document messaging security</a></li>
  </ul>

      </div>
    </section>
  </article>

  
  <section class="disqus pattern-bg-lighter">

    <div id="disqus" class="container">

      <h2>Comments</h2>

      <div id="disqus_thread">

        <a href="#disqus_thread" class="load-comments" data-disqus-identifier="http://www.html5rocks.com/tutorials/eventsource/basics/">0</a>

      </div>
    </div>

    <noscript>
      <p class="center">
        <strong>
          <a href="http://disqus.com/?ref_noscript">Please enable JavaScript to view the comments powered by Disqus.</a>
        </strong>
      </p>
    </noscript>

    <script>

      var disqus_shortname = 'html5rocks';
      var disqus_identifier = 'http://www.html5rocks.com/tutorials/eventsource/basics/';
      var disqus_url = 'http://www.html5rocks.com/tutorials/eventsource/basics/';
      var disqus_developer = 0;

      var disqus_config = function () {
        var funky_language_code_mapping = {
          'de': 'de_inf',
          'es': 'es_ES',
          'pt': 'pt_EU',
          'sr': 'sr_CYRL',
          'sv': 'sv_SE',
          'zh': 'zh_HANT'
        };
        this.language = funky_language_code_mapping['en'] ||
                        'en';

        this.callbacks.onReady = [ function () {
                                      try {
                                        ga('send', 'event', 'View comments');
                                      } catch(err){}
                                   } ];
        this.callbacks.onNewComment = [ function (comment) {
                                          try {
                                            ga('send', 'event', 'Commented');
                                          } catch(err){}
                                        } ];
      };

      window.addEventListener('load', function(e) {

        var c = document.createElement('script');
        c.type = 'text/javascript';
        c.src = 'http://' + disqus_shortname + '.disqus.com/count.js';
        c.async = true;

        var s = document.getElementsByTagName('script')[0], sp = s.parentNode;
        sp.insertBefore(c, s);

        if (window.location.hash === '#disqus_thread')
          loadComments();

      }, false);

      var disqus_loaded = false;
      function loadComments() {

        if (disqus_loaded)
          return;

        disqus_loaded = true;

        ga('send', 'event', 'Interactions', 'Comments', 'Comments Loaded');

        var s = document.getElementsByTagName('script')[0], sp = s.parentNode;
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;

        var disqusContainer = document.getElementById('disqus');
        disqusContainer.classList.add('active');

        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        sp.insertBefore(dsq, s);
      }

      function outgoing(url) {
        try {
          ga('send', 'event', 'Outbound Links' , url);
        } catch(err){}
      }
      // Open external links (also that don't have a target defined) in a new tab.
      var externLinks = document.querySelectorAll('article.tutorial a[href^="http"]:not([target])');
      for(var i = 0, a; a = externLinks[i]; ++i) {
        a.target = '_blank';
        a.addEventListener('click', new Function('outgoing(' + '"' + a.href.replace(/.*?:\/\//g, "") + '"' + ');'));
      }

      var loadCommentsButtons = document.querySelectorAll('.load-comments');
      for(var l = 0; l < loadCommentsButtons.length; l++)
        loadCommentsButtons[l].addEventListener('click', loadComments);

    </script>
  </section>
  

  <footer>
    <div class="container">

      
        <h1>Next steps</h2>

        

        <aside class="panel share">
          <h2>Share</h2>

            <a href="https://twitter.com/share?url=http://www.html5rocks.com/tutorials/eventsource/basics/&text=Stream Updates with Server-Sent Events&lang=en&via=ChromiumDev&related=ChromiumDev" class="twitter" target="_blank">Twitter</a>

            <a href="https://www.facebook.com/sharer/sharer.php?u=http://www.html5rocks.com/tutorials/eventsource/basics/" class="facebook" target="_blank">Facebook</a>

            <a href="https://plus.google.com/share?url=http://www.html5rocks.com/tutorials/eventsource/basics/" class="gplus" onclick="javascript:window.open(this.href, '', 'menubar=no,toolbar=no,resizable=yes,scrollbars=yes,height=600,width=600');return false;">Google+</a>

        </aside>

        <aside class="panel rss">
          <h2>Subscribe</h2>
          <p>Enjoyed this article? Grab the <a href="http://feeds.feedburner.com/html5rocks">RSS feed</a> and stay up-to-date.</p>
        </aside>

      

      <p class="licensing">
      
        Except as otherwise <a href="http://code.google.com/policies.html#restrictions">noted</a>, the content of this page is licensed under the <a href="http://creativecommons.org/licenses/by/3.0/">Creative Commons Attribution 3.0 License</a>, and code samples are licensed under the <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache 2.0 License</a>.
      
      </p>

    </div>
  </footer>

  <script>
    window.isCompatible = function() {
      
  return !!window.EventSource;

    };

    if (isCompatible() === false) {
      document.getElementById('notcompatible').className = '';
    }

    function _prettyPrint() {
      if (typeof customPrettyPrintLanguage != 'undefined') {
        customPrettyPrintLanguage();
      }
      prettyPrint();
    }
  </script>
  <script async src="/static/js/prettify.min.js" onload="_prettyPrint()"></script>
  <!-- Google Tag Manager -->
<noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-XXXX"
height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-MB3LRF');</script>
<!-- End Google Tag Manager -->


  </div>

  <script>
  (function() {

    // Kill feedburner and marketing tracking arguments, but let them register
    // before we do it.
    setTimeout(function() {
      if (/^\?utm_/.test(document.location.search) &&
          window.history.replaceState) {
        window.history.replaceState(
            {}, '', document.location.href.replace(/\?utm_.*/, ''));
      }
    }, 2000);

    var siteHeader = document.getElementById('siteheader');
    var navToggle = document.getElementById('navtoggle');
    var siteNav = document.getElementById('sitenav');

    function toggle(target, forceActive) {

      if (typeof toc !== 'undefined') {
        // Switch off whichever one is not the
        // current target
        if (target === toc)
          siteNav.classList.remove('active');
        else
          toc.classList.remove('active');
      }

      // Toggle if no force parameter is set
      if (typeof forceActive === 'undefined') {
        target.classList.toggle('active');
      } else {
        if (forceActive)
          target.classList.add('active');
        else
          target.classList.remove('active');
      }

      // now find out what the set state ended up being
      var isActive = target.classList.contains('active');

      if (isActive)
        siteHeader.classList.add('expanded');
      else
        siteHeader.classList.remove('expanded');

    }

    navToggle.addEventListener('click', function(e) {
      toggle(siteNav);
      e.preventDefault();
    });

    

    var tocToggle = document.getElementById('toctoggle');
    var toc = document.getElementById('toc');
    var articleMeta = document.getElementById('article-meta');
    var articleContent = document.getElementById('article-content');
    var articleMetaHeight = 0;
    var articleMetaMaxY = 0;
    var articleMetaMinY = 0;
    var articleContentPadding = 200;

    var tocLinks = document.querySelectorAll('.toc a');
    for (var t = 0; t < tocLinks.length; t++)
      tocLinks[t].addEventListener('click', onTocLinkClick);

    tocToggle.addEventListener('click', function(e) {
      toggle(toc);
      e.preventDefault();
    });

    toc.addEventListener('click', function(e) {
      if (e.target !== siteNav)
        toggle(toc, false);
    });

    function onTocLinkClick() {
      ga('send', 'event', 'Interactions', 'TOC', 'TOC Clicked');
    }

    function setMinScrollYFromMetaY() {
      var scrollPosition = window.scrollY;

      var articleMetaBounds = articleMeta.getBoundingClientRect();
      var articleMetaTop = Math.max(352,
          articleMetaBounds.top - 20 + scrollPosition);

      articleMetaHeight = articleMetaBounds.bottom - articleMetaBounds.top;
      articleMetaMinY = articleMetaTop;
    }

    function setMaxScrollYFromContentHeight() {

      var scrollPosition = window.scrollY;

      var articleContentBounds = articleContent.getBoundingClientRect();
      var articleContentTop = articleContentBounds.top + scrollPosition;
      var articleContentHeight = articleContentBounds.bottom - articleContentBounds.top;

      articleMetaMaxY = articleContentTop +
          articleContentHeight -
          articleMetaHeight -
          articleContentPadding;

    }

    function onScroll(e) {

      if (window.scrollY >= articleMetaMinY) {

        articleMeta.classList.add('sticky');

        var articleMetaTop = 22 - Math.max(0, window.scrollY - articleMetaMaxY);
        articleMeta.style.top = articleMetaTop + 'px';

      } else {
        articleMeta.classList.remove('sticky');
        articleMeta.style.top = 'auto';
      }
    }

    if (articleMeta.getBoundingClientRect) {
      setMinScrollYFromMetaY();
      setMaxScrollYFromContentHeight();
      document.addEventListener('scroll', onScroll);
      window.addEventListener('load', setMaxScrollYFromContentHeight, false);
    }

    
  })();
  </script>
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-15028909-1', 'auto');
  ga('create', 'UA-49880327-4', 'auto', {'name': 'html5rocks'});

  ga('send', 'pageview');
  ga('html5rocks.send', 'pageview');

  </script>
   <!-- Google Tag Manager -->
<noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-XXXX"
height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-MB3LRF');</script>
<!-- End Google Tag Manager -->
</body>
</html>
